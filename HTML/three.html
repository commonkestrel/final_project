<!DOCTYPE html>
<html>
    <head>
        <style>
            html {
                scroll-behavior: smooth;
                background-color: white;
            }
            canvas {
                position: fixed !important;
                top: 0px !important;
                left: 0px !important;
            }
            body {
                overflow-x: hidden;
                height: 5000vh;
                background-color: white;
            }
            body > * {
                position: fixed;
            }
            ::-webkit-scrollbar {
                width: 15px;
                background: #000;
            }
            
            /* Handle */
            ::-webkit-scrollbar-thumb {
                background: rgb(109, 109, 109);
                border-radius: 8px;
            }
            
            /* Handle on hover */
            ::-webkit-scrollbar-thumb:hover {
                background: #555;
            }
        </style>
    </head>
    <body>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.js"></script>
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
        <script>
            $(document).ready(() => {
                window.scroll(0, 0)
                const originScrollY = 0;
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0x000)
                originalAspect = window.innerWidth / window.innerHeight;
                const camera = new THREE.PerspectiveCamera(50, originalAspect, 0.1, 1000);
                const renderer = new THREE.WebGLRenderer({alpha: true});
                scene.background = null;
                renderer.setSize( window.innerWidth, window.innerHeight );
                document.body.appendChild( renderer.domElement );
                renderer.domElement.classList.toggle("renderer")

                let inverted = false;
                const end_pos = 0;

                //Load textures
                const loader = new THREE.TextureLoader();
                const scanline_texture = loader.load('https://jibble330.pythonanywhere.com/files/networking-earth.png')
                const black_texture = loader.load('https://jibble330.pythonanywhere.com/files/world-outline-black.png');
                const white_texture = loader.load('https://jibble330.pythonanywhere.com/files/world-outline-white.png');

                //Initiallize sphere
                const geometry = new THREE.SphereGeometry(2, 32, 32);
                const material = new THREE.MeshBasicMaterial({map: scanline_texture});
                const sphere = new THREE.Mesh(geometry, material);
                sphere.position.x = 15;
                scene.add(sphere);

                //Initiallize objects for view shift
                const ellipse = new THREE.EllipseCurve(0, 0, 10+end_pos, 10, 0, 0.5 * Math.PI, false);
                const ellipse_points = ellipse.getSpacedPoints(100).reverse();
                const view_curve = new THREE.EllipseCurve(0, 0, end_pos, end_pos, 0.5 * Math.PI, Math.PI, false);
                const view_points = view_curve.getPoints(100).reverse()

                const animate = (amount) => {
                    const move_end_pixel = 247 * (-end_pos+15)
                    const curve_end_pixel = move_end_pixel + (247 * 15)
                    if(window.pageYOffset < move_end_pixel) {
                        sphere.position.x = (window.pageYOffset * 0.004)-15;
                        sphere.rotation.y -= amount;
                    } else if(sphere.position.x != end_pos) {
                        sphere.position.x = end_pos;
                        sphere.rotation.y -= amount;
                    }
                    if(window.pageYOffset > move_end_pixel && window.pageYOffset < curve_end_pixel) {
                        const amount = Math.floor((window.pageYOffset - move_end_pixel)/37.05);
                        const vector = ellipse_points[amount]
                        const translated_point = rotateX(vector, 65);
                        translated_point.y -= below;
                        const view_vector = view_points[amount];
                        const translated_view = new THREE.Vector3(view_vector.x+end_pos, 0, view_vector.y);
                        curve(translated_point, translated_view)
                    }

                    renderer.render(scene, camera);
                };
                const invert = () => {
                    if(inverted) {
                        material.map = black_texture;
                    } else {
                        material.map = white_texture;
                    }
                    material.map.needsUpdate = true;
                    renderer.render(scene, camera);
                    inverted = !inverted;
                }
                const delay_invert = (i) => {
                    setTimeout(() => {
                        invert()
                        if (i < 11) {
                            delay_invert(i+1)
                        }
                    },50)
                }

                const curve = (point, look) => {
                    camera.position.copy(point)
                    camera.lookAt(look)
                    renderer.render(scene, camera);
                }

                const rotateX = (point, angle) => {
                    const radians = angle * Math.PI/180;
                    const rot_z = point.y * Math.sin(radians);
                    const rot_y = point.y * Math.cos(radians);
                    const rot_point = new THREE.Vector3(point.x, -rot_y, rot_z)
                    return rot_point;
                }

                const curve_move = () => {
                    for(let i=0; i<ellipse_points.length; i++) {
                        const vector = ellipse_points[i]
                        const translated_point = rotateX(vector, 65);
                        translated_point.y -= below
                        const view_vector = view_points[i]
                        const translated_view = new THREE.Vector3(view_vector.x+end_pos, 0, view_vector.y)
                    }
                }
                const below = rotateX(ellipse_points[0], 65).y
                camera.position = ellipse_points[0]
                camera.position.y += below
                animate(0);

                let lastScrollY = window.pageYOffset;
                $(document).click(() => {
                    //delay_invert(0)
                    //$('html, body').animate({'scrollTop': '+=5000vh'}) 
                })
                $(window).scroll(() => {
                    let amount = (this.pageYOffset - lastScrollY) * 0.002;
                    lastScrollY = window.pageYOffset;
                    animate(amount)
                });
            });
        </script>
    </body>
</html>
